---
layout:     post                    # 使用的布局（不需要改）
title:      Crypto                  # 标题 
subtitle:   密码学就是数学           #副标题
date:       2018-08-02              # 时间
author:     RTL                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - CTF
    - Crypto
---

# 密码学

## 古典密码学

### 替换加密

#### 单表替换加密

- 一种映射(基本是一一映射)
- 破解方法
  - 密钥空间过小时 爆破！
  - [分析网站](http://quipquip.com)

- **凯撒密码**
  - 移位
  - 攻击 爆破
  - 空间变大的凯撒密码？凯撒密码还要什么自行车，直接爆破
  - 若不改变距离，简化方法，将乱码移位到可见空间内
- **Atbash Cipher**
  - A -> Z   Z -> A  B -> Y  Y -> B ...
- **Polybius**
  - 棋盘加密，二次坐标系编码，类似于有序数对
- **仿射密码**
  - E(x) = (a * x + b) mod N
  - **逆元**
    - A * B mod N = 1 则 A B 互为逆元
    - [扩展欧几里得算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95) (线性代数?)
  - **欧拉函数**
    - [定义](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)
    - 计算出 a 的可能性，爆破
- **真·单表替换**
  - 字频分析

#### 多表替换加密

- **Vigenere**
  - 其实是26个凯撒
  - 卡西斯基试验
    - 一定间隔的相同字符串被加密成相同密文
  - 弗里德曼试验
    - 凯撒加密不改变所有字母的概率平方和
  - Vigenere 3D
- **Playfair**
  - [定义](https://zh.wikipedia.org/wiki/%E6%B3%A2%E9%9B%B7%E8%B2%BB%E5%AF%86%E7%A2%BC)
  - 顺序相反的字母会泄露信息

#### 置换加密

- **栅栏加密**

#### 其他算法

- **Hill**
  - 矩阵运算
  - 达成了 difussion，按块加密
- **培根加密**
  - 其实就是一种编码
- **BarinFuck**
- **JSFUck**[生成地址](http://www.jsfuck.com/)
- **猪圈密码**
- **base64**
  - 最后几位可以做隐写
- **base32**
- **base16**

### 流加密

- OTP 完善保密性
- 熵
  - 不确定性的量度
  - 如英语26个字母，每个字母讯息量为 -ln(1/26) = 4.7
- 伪随机数生成器
- 线性同余生成器
- LFSR(线性反馈移位寄存器)
  - 为本原多项式时长度才为 2^n
  - 需要一个非线性函数来确保安全
  - [维基百科](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%8F%8D%E9%A6%88%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8)

### 块加密

- 混淆与扩散
- 迭代分组密码
- Feistel
  - [DES](https://baike.baidu.com/item/DES)
  - [AES](https://baike.baidu.com/item/aes/5903)
    - AddRoundKey — 矩阵中的每一个字节都与该次轮秘钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。
    - SubBytes — 通过非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。
    - ShiftRows — 将矩阵中的每个横列进行循环式移位。
    - MixColumns — 为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每列的四个字节。
    - *最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。*

### 分组密码加密模式 [Link](https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)

- ECB
  - 一个很大的缺点，由于是分组，可以直接改变顺序，如将银行账户的收款人与付款人互换
  - ECB加密代码 [引用地址](http://www.cnblogs.com/dacainiao/p/5521646.html)

```c
#include <STRING.H>
#define IN
#define OUT

//假设加密分组为4字节一组
/**************************************************************************
*功  能:    加密算法 (与Key异或)
*参  数:    lpszData        当前明文分组数据
*           lpszKey         Key
*           lpszDeData      加密后的结果
*
*返回值:
**************************************************************************/
void Encrypt(IN const char *lpszData, IN const char *lpszKey, OUT char *lpszEnData)
{
  int i = 0;
  for (i = 0; i < 4; i++)
  {
      lpszEnData[i] = lpszData[i] ^ lpszKey[i];
  }
}

/**************************************************************************
*功  能:    解密算法 (再次异或还原明文)
*参  数:    lpszData        当前密文分组数据
*           lpszKey         Key
*           lpszDeData      解密后的结果
*
*返回值:
**************************************************************************/
void Decrypt(IN const char *lpszData, IN const char *lpszKey, OUT char *lpszDeData)
{
    int i = 0;
    for (i = 0; i < 4; i++)
    {
        lpszDeData[i] = lpszData[i] ^ lpszKey[i];
    }
}

int main(int argc, char* argv[])
{
    char *lpszData = "Hello World!";
    char szEnData[16] = {0};
    char szDeData[16] = {0};
    char *lpszKey = "1234";
    int i = 0;

    printf("原始数据: %s\r\n", lpszData);

    while (true)
    {
        if (strlen(lpszData + i) == 0)
        {
            break;
        }
        Encrypt(lpszData + i, lpszKey, szEnData + i);
        i += 4;
    }

    printf("加密后数据: %s\r\n", szEnData);

    i = 0;
    while (true)
    {
        if (strlen(szEnData + i) == 0)
        {
            break;
        }
        Decrypt(szEnData + i, lpszKey, szDeData + i);
        i += 4;
    }

    printf("解密后数据: %s\r\n", szDeData);
    return 0;
}
```

- CBC(PCBC)
  - CBC模式优点：
    - 不容易主动攻击, 安全性好于ECB, 适合传输长度长的报文, 是SSL、IPSec的标准
  - CBC模式缺点：
    - 不利于并行计算
    - 误差传递
    - 需要初始化向量IV
  - CBC加密解密代码 [引用地址](http://www.cnblogs.com/dacainiao/p/5521866.html)

```c
#include <STRING.H>

#define IN
#define OUT

//假设加密分组为4字节一组

/**************************************************************************
*功  能:    加密算法 (与Key异或)
*参  数:    lpszData        当前明文分组数据
*           lpszKey         Key    
*           lpszDeData      加密后的结果
*
*返回值:    
**************************************************************************/
void Encrypt(IN const char *lpszData, IN const char *lpszKey, OUT char *lpszEnData)
{
    int i = 0;
    for (i = 0; i < 4; i++)
    {
        lpszEnData[i] = lpszData[i] ^ lpszKey[i];
    }
}

/**************************************************************************
*功  能:    解密算法 (再次异或还原明文)
*参  数:    lpszData        当前密文分组数据
*           lpszKey         Key
*           lpszDeData      解密后的结果
*
*返回值:    
**************************************************************************/
void Decrypt(IN const char *lpszData, IN const char *lpszKey, OUT char *lpszDeData)
{
    int i = 0;
    for (i = 0; i < 4; i++)
    {
        lpszDeData[i] = lpszData[i] ^ lpszKey[i];
    }
}

/**************************************************************************
*功  能:    与前一个密文分组进行xor
*参  数:    lpszData        当前明文分组数据
*           lpszPreEnData   前一个密文分组
*           lpszDeData      保存异或后的数据
*
*返回值:
**************************************************************************/
void XorEnGroup(IN const char *lpszData, IN const char *lpszPreEnData, OUT char *lpszDeData)
{
    int i = 0;
    for (i = 0; i < 4; i++)
    {
        lpszDeData[i] = lpszData[i] ^ lpszPreEnData[i];
    }
}

int main(int argc, char* argv[])
{
    char szData[] = "Hello World!";
    char szEnData[16] = {0};
    char szDeData[16] = {0};
    char *lpszKey = "1234";
    int i = 0;
    char szIV[] = "9999";

    printf("原始数据: %s\r\n", szData);

    while (true)
    {
        if (strlen(szData + i) == 0)
        {
            break;
        }

        //首先需要与前一个密文分组进行xor
        XorEnGroup(szData + i, szIV, szData + i);

        //更新密文分组
        Encrypt(szData + i, lpszKey, szIV);

        memcpy(szEnData + i, szIV, 4);

        i += 4;
    }

    printf("加密后数据: %s\r\n", szEnData);

    memcpy(szIV, "9999", 4);

    i = 0;
    char szPreEnData[8] = {0};

    while (true)
    {
        if (strlen(szEnData + i) == 0)
        {
            break;
        }

        memcpy(szPreEnData, szEnData + i, 4);

        //先解密
        Decrypt(szEnData + i, lpszKey, szEnData + i);

        //再与前一个密文分组进行xor
        XorEnGroup(szData + i, szIV, szDeData + i);

        memcpy(szIV, szPreEnData, 4);

        i += 4;
    }

    printf("解密后数据: %s\r\n", szDeData);

    return 0;
}
```

- Padding Oracle Attack

### 公钥算法

- Discrete log problem
  - CDH
  - DDH
- Integer Factorization
- RSA problem
  - 费马小定理
- 快速幂算法
  - 优化复杂度，平均复杂度为 1.5 * O(log(n))

```cs
int FastExp(int a, int b, int N)
{
    int ans = 1;
    a = a % N;
    while(b) {
      if(b % 2 == 1) {
        ans = (ans * a) % N;
      }
      b = b / 2;
      a = (a * a) % N;
    }
    return ans;
}
```

- 中国剩余定理？

### 参考文献

- [POA](http://blog.zhaojie.me/2010/10/padding-oracle-attack-in-detail.html)
- [AES](https://baike.baidu.com/item/aes/5903)
- [Block cipher mode of operation](https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F)
- [流加密](https://zh.wikipedia.org/wiki/流加密)
- [欧拉函数](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0)
- [扩展欧几里得算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)
- [常见密码学攻击](http://seaii-blog.com/index.php/2017/05/13/60.html)